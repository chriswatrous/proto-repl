// Generated by CoffeeScript 1.12.7
(function() {
  var ClojureVersion, EditorUtils, NReplConnection, nrepl,
    slice = [].slice;

  nrepl = require('jg-nrepl-client');

  ClojureVersion = require('./clojure-version');

  EditorUtils = require('../editor-utils');

  module.exports = NReplConnection = (function() {
    function NReplConnection() {}

    NReplConnection.prototype.conn = null;

    NReplConnection.prototype.session = null;

    NReplConnection.prototype.cmdSession = null;

    NReplConnection.prototype.sessionsByName = {};

    NReplConnection.prototype.clojureVersion = null;

    NReplConnection.prototype.determineClojureVersion = function(callback) {
      return this.conn["eval"]("*clojure-version*", "user", this.session, (function(_this) {
        return function(err, messages) {
          var msg, value;
          value = ((function() {
            var i, len, results;
            results = [];
            for (i = 0, len = messages.length; i < len; i++) {
              msg = messages[i];
              results.push(msg.value);
            }
            return results;
          })())[0];
          _this.clojureVersion = new ClojureVersion(window.protoRepl.parseEdn(value));
          if (!_this.clojureVersion.isSupportedVersion()) {
            atom.notifications.addWarning("WARNING: This version of Clojure is not supported by Proto REPL. You may experience issues.", {
              dismissable: true
            });
          }
          return callback();
        };
      })(this));
    };

    NReplConnection.prototype.startMessageHandling = function(messageHandler) {
      return this.conn.messageStream.on("messageSequence", (function(_this) {
        return function(id, messages) {
          var i, len, msg, results;
          if (!_this.namespaceNotFound(messages)) {
            results = [];
            for (i = 0, len = messages.length; i < len; i++) {
              msg = messages[i];
              if (msg.ns && msg.session === _this.session) {
                _this.currentNs = msg.ns;
              }
              if (msg.session === _this.session) {
                results.push(messageHandler(msg));
              } else if (msg.session === _this.cmdSession && msg.out) {
                results.push(messageHandler(msg));
              } else {
                results.push(void 0);
              }
            }
            return results;
          }
        };
      })(this));
    };

    NReplConnection.prototype.connected = function() {
      return this.conn !== null;
    };

    NReplConnection.prototype.getCurrentNs = function() {
      return this.currentNs;
    };

    NReplConnection.prototype.codeMayContainReaderConditional = function(code) {
      return code.includes("#?");
    };

    NReplConnection.prototype.wrapCodeInReadEval = function(code) {
      var escapedStr, ref;
      if (((ref = this.clojureVersion) != null ? ref.isReaderConditionalSupported() : void 0) && this.codeMayContainReaderConditional(code)) {
        escapedStr = EditorUtils.escapeClojureCodeInString(code);
        return "(eval (read-string {:read-cond :allow} " + escapedStr + "))";
      } else {
        return code;
      }
    };

    NReplConnection.prototype.namespaceNotFound = function(messages) {
      var i, len, msg, ref;
      for (i = 0, len = messages.length; i < len; i++) {
        msg = messages[i];
        if (((ref = msg.status) != null ? ref.length : void 0) > 0) {
          if (msg.status[0] === "namespace-not-found") {
            return true;
          }
        }
      }
    };

    NReplConnection.prototype.optionsToSessions = function(options, callback) {
      var s;
      if (options.allSessions) {
        return callback([this.session, this.cmdSession].concat(slice.call(Object.values(this.sessionsByName))));
      } else if (options.session) {
        if (s = this.sessionsByName[options.session]) {
          return callback([s]);
        } else {
          return this.conn.clone((function(_this) {
            return function(err, messages) {
              s = messages[0]["new-session"];
              _this.sessionsByName[options.session] = s;
              return callback([s]);
            };
          })(this));
        }
      } else if (options.displayInRepl === false) {
        return callback([this.cmdSession]);
      } else {
        return callback([this.session]);
      }
    };

    NReplConnection.prototype.sendCommand = function(code, options, resultHandler) {
      if (!this.connected()) {
        return null;
      }
      return this.optionsToSessions(options, (function(_this) {
        return function(sessions) {
          return sessions.forEach(function(session) {
            var evalOptions, ns, ref, ref1, wrappedCode;
            wrappedCode = _this.wrapCodeInReadEval(code);
            ns = options.ns || _this.currentNs;
            evalOptions = {
              op: "eval",
              code: wrappedCode,
              ns: ns,
              session: session
            };
            if ((options != null ? (ref = options.inlineOptions) != null ? ref.range : void 0 : void 0) != null) {
              evalOptions.line = options.inlineOptions.range.start.row + 1;
              evalOptions.column = options.inlineOptions.range.start.column + 1;
            }
            if (options != null ? (ref1 = options.inlineOptions) != null ? ref1.editor : void 0 : void 0) {
              evalOptions.file = options.inlineOptions.editor.getPath();
            }
            return _this.conn.send(evalOptions, function(err, messages) {
              var error, i, len, msg, results;
              try {
                if (_this.namespaceNotFound(messages)) {
                  if (!options.retrying) {
                    options.retrying = true;
                    options.ns = _this.currentNs;
                    return _this.sendCommand(code, options, resultHandler);
                  }
                } else {
                  results = [];
                  for (i = 0, len = messages.length; i < len; i++) {
                    msg = messages[i];
                    if (msg.value) {
                      results.push(resultHandler({
                        value: msg.value
                      }));
                    } else if (msg.err) {
                      results.push(resultHandler({
                        error: msg.err
                      }));
                    } else {
                      results.push(void 0);
                    }
                  }
                  return results;
                }
              } catch (error1) {
                error = error1;
                console.error(error);
                return atom.notifications.addError("Error in handler: " + error, {
                  detail: error,
                  dismissable: true
                });
              }
            });
          });
        };
      })(this));
    };

    NReplConnection.prototype.close = function() {
      if (!this.connected()) {
        return null;
      }
      this.conn.close(this.session, (function(_this) {
        return function() {};
      })(this));
      this.conn.close(this.cmdSession, (function(_this) {
        return function() {};
      })(this));
      this.sessionsByName = {};
      return this.conn = null;
    };

    return NReplConnection;

  })();

}).call(this);
