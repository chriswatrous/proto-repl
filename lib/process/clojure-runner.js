// Generated by CoffeeScript 1.12.7
(function() {
  var _, childProcess, filteredEnv, fs, path;

  childProcess = require('child_process');

  path = require('path');

  fs = require('fs');

  _ = require('underscore');

  filteredEnv = _.omit(process.env, 'ATOM_HOME', 'ATOM_SHELL_INTERNAL_RUN_AS_NODE', 'GOOGLE_API_KEY', 'NODE_ENV', 'NODE_PATH', 'userAgent', 'taskPath');

  module.exports = function(currentWorkingDir, clojurePath) {
    var args, callback, clojureExec, envPath, error, portFound, processData, replProcess;
    callback = this.async();
    args = ["-e", "(do (require '[clojure.tools.nrepl.server :refer [start-server]]) (let [port (:port (start-server))] (println (str \"nREPL server started on port \" port \" on host 127.0.0.1\")) (println (str \"- nrepl://127.0.0.1:\" port))))", "-r"];
    portFound = false;
    processData = function(data) {
      var dataStr, match, port;
      dataStr = data.toString();
      if (!portFound) {
        if (match = dataStr.match(/.*nREPL.*port (\d+)/)) {
          portFound = true;
          port = Number(match[1]);
          emit('proto-repl-process:nrepl-port', port);
        }
      }
      return emit('proto-repl-process:data', dataStr);
    };
    try {
      clojureExec = "clj";
      envPath = filteredEnv["PATH"] || "";
      filteredEnv["PATH"] = envPath + path.delimiter + clojurePath;
      replProcess = childProcess.spawn(clojureExec, args, {
        cwd: currentWorkingDir,
        env: filteredEnv
      });
      replProcess.stdout.on('data', processData);
      replProcess.stderr.on('data', processData);
      replProcess.on('error', function(error) {
        return processData("Error starting repl: " + error + "\nYou may need to configure the clojure path in proto-repl settings\n");
      });
      replProcess.on('close', function(code) {
        emit('proto-repl-process:exit');
        return callback();
      });
    } catch (error1) {
      error = error1;
      processData("Error starting repl: " + error);
    }
    return process.on('message', function(arg) {
      var event, ref, text;
      ref = arg != null ? arg : {}, event = ref.event, text = ref.text;
      try {
        switch (event) {
          case 'input':
            return replProcess.stdin.write(text);
          case 'kill':
            return replProcess.kill("SIGKILL");
        }
      } catch (error1) {
        error = error1;
        return console.error(error);
      }
    });
  };

}).call(this);
