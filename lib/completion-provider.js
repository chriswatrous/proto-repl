// Generated by CoffeeScript 1.12.7
(function() {
  var EditorUtils, Point, Range, bufferPositionContext, completionToSuggestion, completionsCode, getPrefix, ref, self_hosted_clj;

  ref = require('atom'), Range = ref.Range, Point = ref.Point;

  EditorUtils = require('./editor-utils');

  self_hosted_clj = require('./proto_repl/self_hosted.js');

  completionToSuggestion = function(prefix, arg) {
    var candidate, docs, type;
    candidate = arg.candidate, docs = arg.docs, type = arg.type;
    return {
      text: candidate,
      type: type,
      description: docs,
      replacementPrefix: prefix
    };
  };

  bufferPositionContext = function(editor, pos, prefix) {
    var beginning, beginningEnd, ending, range, ranges;
    ranges = EditorUtils.getTopLevelRanges(editor);
    range = ranges.find(function(range) {
      return range.containsPoint(pos);
    });
    if (range) {
      beginningEnd = new Point(pos.row, pos.column - prefix.length);
      beginning = editor.getTextInBufferRange(new Range(range.start, beginningEnd));
      ending = editor.getTextInBufferRange(new Range(pos, range.end));
      return beginning + "__prefix__" + ending;
    } else {
      return "nil";
    }
  };

  completionsCode = function(editor, bufferPosition, prefix) {
    var context, escapedStr, ns;
    context = bufferPositionContext(editor, bufferPosition, prefix);
    ns = EditorUtils.findNsDeclaration(editor) || "nil";
    escapedStr = EditorUtils.escapeClojureCodeInString(context);
    return "(do (require 'compliment.core) (let [completions (compliment.core/completions \"" + prefix + "\" {:tag-candidates true :ns '" + ns + " :context " + escapedStr + "})] (->> completions (take 50) (mapv #(assoc % :docs (compliment.core/documentation (:candidate %) '" + ns + "))))))";
  };

  getPrefix = function(editor, bufferPosition) {
    var line, ref1, regex;
    regex = /[A-Za-z0-9_\-><\/.?!*:]+$/;
    line = editor.getTextInRange([[bufferPosition.row, 0], bufferPosition]);
    return ((ref1 = line.match(regex)) != null ? ref1[0] : void 0) || '';
  };

  module.exports = {
    scopeSelector: '.source.clojure',
    textEditorSelectors: 'atom-text-editor',
    disableForScopeSelector: '.source.clojure .comment, .source.clojure .string',
    inclusionPriority: 100,
    excludeLowerPriority: false,
    getTextEditorSelector: function() {
      return 'atom-text-editor';
    },
    getSuggestions: function(arg) {
      var bufferPosition, editor, prefix, scopeDescriptor;
      editor = arg.editor, bufferPosition = arg.bufferPosition, scopeDescriptor = arg.scopeDescriptor;
      prefix = getPrefix(editor, bufferPosition);
      if (prefix !== "") {
        return new Promise(function(resolve) {
          var code;
          if (!window.protoRepl.running()) {
            return resolve([]);
          } else if (window.protoRepl.isSelfHosted()) {
            return self_hosted_clj.completions(prefix, function(matches) {
              var c, suggestions;
              suggestions = (function() {
                var i, len, results;
                results = [];
                for (i = 0, len = matches.length; i < len; i++) {
                  c = matches[i];
                  results.push(completionToSuggestion(prefix, c));
                }
                return results;
              })();
              return resolve(suggestions);
            });
          } else {
            code = completionsCode(editor, bufferPosition, prefix);
            return window.protoRepl.executeCode(code, {
              displayInRepl: false,
              resultHandler: function(result) {
                var c, completions, suggestions;
                if (result.error) {
                  console.log(result.error);
                  return resolve([]);
                } else {
                  completions = window.protoRepl.parseEdn(result.value);
                  suggestions = (function() {
                    var i, len, results;
                    results = [];
                    for (i = 0, len = completions.length; i < len; i++) {
                      c = completions[i];
                      results.push(completionToSuggestion(prefix, c));
                    }
                    return results;
                  })();
                  return resolve(suggestions);
                }
              }
            });
          }
        });
      }
    }
  };

}).call(this);
