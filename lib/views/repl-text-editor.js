// Generated by CoffeeScript 1.12.7
(function() {
  var EDIT_DELIMITER, Emitter, Point, Range, ReplHistory, ReplTextEditor, TAB_TITLE, ref;

  ref = require('atom'), Range = ref.Range, Point = ref.Point, Emitter = ref.Emitter;

  ReplHistory = require('./repl-history');

  EDIT_DELIMITER = "--------------------\n";

  TAB_TITLE = "Clojure REPL";

  module.exports = ReplTextEditor = (function() {
    ReplTextEditor.prototype.emitter = null;

    ReplTextEditor.prototype.textEditor = null;

    ReplTextEditor.prototype.allowAnyChange = false;

    ReplTextEditor.prototype.delimiterRow = 0;

    ReplTextEditor.prototype.replHistory = null;

    function ReplTextEditor() {
      var options;
      this.emitter = new Emitter;
      if (atom.config.get("proto-repl.openReplInRightPane")) {
        options = {
          split: 'right'
        };
      } else {
        options = {};
      }
      atom.workspace.open(TAB_TITLE, options).then((function(_this) {
        return function(textEditor) {
          window.textEditor = textEditor;
          _this.configureNewTextEditor(textEditor);
          _this.emitter.emit('proto-repl-text-editor:open');
          _this.replHistory = new ReplHistory();
          _this.onHistoryBack(function() {
            _this.replHistory.setCurrentText(_this.enteredText());
            return _this.setEnteredText(_this.replHistory.back());
          });
          return _this.onHistoryForward(function() {
            _this.replHistory.setCurrentText(_this.enteredText());
            return _this.setEnteredText(_this.replHistory.forward());
          });
        };
      })(this))["catch"]((function(_this) {
        return function(err) {
          return console.error(err);
        };
      })(this));
    }

    ReplTextEditor.prototype.onDidOpen = function(callback) {
      if (this.textEditor) {
        return callback();
      } else {
        return this.emitter.on('proto-repl-text-editor:open', callback);
      }
    };

    ReplTextEditor.prototype.onDidClose = function(callback) {
      return this.emitter.on('proto-repl-text-editor:close', callback);
    };

    ReplTextEditor.prototype.clear = function() {
      if (this.textEditor) {
        return this.modifyTextWith((function(_this) {
          return function() {
            _this.textEditor.setText(EDIT_DELIMITER);
            return _this.delimiterRow = 0;
          };
        })(this));
      }
    };

    ReplTextEditor.prototype.enteredTextRange = function() {
      var end, start;
      start = new Point(this.delimiterRow + 1);
      end = this.textEditor.buffer.getEndPosition();
      return new Range(start, end);
    };

    ReplTextEditor.prototype.enteredText = function() {
      return this.textEditor.getTextInBufferRange(this.enteredTextRange());
    };

    ReplTextEditor.prototype.setEnteredText = function(text) {
      return this.modifyTextWith((function(_this) {
        return function() {
          return _this.textEditor.setTextInBufferRange(_this.enteredTextRange(), text);
        };
      })(this));
    };

    ReplTextEditor.prototype.clearEnteredText = function() {
      return this.setEnteredText("");
    };

    ReplTextEditor.prototype.modifyTextWith = function(f) {
      this.allowAnyChange = true;
      f();
      return this.allowAnyChange = false;
    };

    ReplTextEditor.prototype.onHistoryBack = function(callback) {
      return this.emitter.on('proto-repl-text-editor:history-back', callback);
    };

    ReplTextEditor.prototype.onHistoryForward = function(callback) {
      return this.emitter.on('proto-repl-text-editor:history-forward', callback);
    };

    ReplTextEditor.prototype.configureTextEditorBasics = function() {
      var grammar;
      this.textEditor.editorElement.className += " proto-repl-repl";
      this.textEditor.getTitle = function() {
        return TAB_TITLE;
      };
      this.textEditor.emitter.emit('did-change-title', TAB_TITLE);
      this.textEditor.isModified = function() {
        return false;
      };
      if (atom.config.get('proto-repl.useClojureSyntax')) {
        grammar = atom.grammars.grammarForScopeName('source.clojure');
        this.textEditor.setGrammar(grammar);
      }
      return this.textEditor.setSoftWrapped(true);
    };

    ReplTextEditor.prototype.configureTextEditorClose = function() {
      return this.textEditor.onDidDestroy((function(_this) {
        return function() {
          _this.emitter.emit('proto-repl-text-editor:close');
          return _this.textEditor = null;
        };
      })(this));
    };

    ReplTextEditor.prototype.allowsRangeChange = function(range) {
      return range.start.row > this.delimiterRow && range.end.row > this.delimiterRow;
    };

    ReplTextEditor.prototype.allowsChange = function(change) {
      return this.allowAnyChange || (this.allowsRangeChange(change.newRange) && this.allowsRangeChange(change.oldRange));
    };

    ReplTextEditor.prototype.configureBufferChanges = function() {
      var shouldAllowChange;
      this.clear();
      shouldAllowChange = (function(_this) {
        return function(change) {
          return _this.allowsChange(change);
        };
      })(this);
      this.textEditor.buffer.oldApplyChange = this.textEditor.buffer.applyChange;
      return this.textEditor.buffer.applyChange = function(change) {
        var changeForCompare, newExtent, newStart, oldExtent, start;
        newStart = change.newStart, oldExtent = change.oldExtent, newExtent = change.newExtent;
        start = Point.fromObject(newStart);
        newExtent = newExtent || Range.fromText(newStart, change.newText).getExtent();
        changeForCompare = {
          oldRange: Range(start, start.traverse(oldExtent || start)),
          newRange: Range(start, start.traverse(newExtent))
        };
        if (shouldAllowChange(changeForCompare)) {
          return this.oldApplyChange(change);
        }
      };
    };

    ReplTextEditor.prototype.configureHistorySupport = function() {
      var atBottomOfEditArea, atTopOfEditArea, triggerHistoryBack, triggerHistoryForward;
      atTopOfEditArea = (function(_this) {
        return function(editor) {
          return editor.getCursorBufferPosition().row - 1 === _this.delimiterRow;
        };
      })(this);
      triggerHistoryBack = (function(_this) {
        return function() {
          return _this.emitter.emit("proto-repl-text-editor:history-back");
        };
      })(this);
      this.textEditor.oldMoveUp = this.textEditor.moveUp;
      this.textEditor.moveUp = function(lineCount) {
        if (atTopOfEditArea(this)) {
          return triggerHistoryBack();
        } else {
          return this.oldMoveUp(lineCount);
        }
      };
      atBottomOfEditArea = (function(_this) {
        return function(editor) {
          return editor.getCursorBufferPosition().row === editor.buffer.getEndPosition().row;
        };
      })(this);
      triggerHistoryForward = (function(_this) {
        return function() {
          return _this.emitter.emit("proto-repl-text-editor:history-forward");
        };
      })(this);
      this.textEditor.oldMoveDown = this.textEditor.moveDown;
      return this.textEditor.moveDown = function(lineCount) {
        if (atBottomOfEditArea(this)) {
          return triggerHistoryForward();
        } else {
          return this.oldMoveDown(lineCount);
        }
      };
    };

    ReplTextEditor.prototype.configureNewTextEditor = function(textEditor) {
      this.textEditor = textEditor;
      this.configureTextEditorBasics();
      this.configureTextEditorClose();
      this.configureBufferChanges();
      return this.configureHistorySupport();
    };

    ReplTextEditor.prototype.autoscroll = function() {
      var ref1, ref2;
      if (atom.config.get('proto-repl.autoScroll')) {
        return (ref1 = this.textEditor) != null ? ref1.scrollToBufferPosition([(ref2 = this.textEditor) != null ? ref2.getLastBufferRow() : void 0, 0]) : void 0;
      }
    };

    ReplTextEditor.prototype.appendText = function(text, waitUntilOpen) {
      if (waitUntilOpen == null) {
        waitUntilOpen = false;
      }
      if (waitUntilOpen && !this.textEditor) {
        return this.onDidOpen((function(_this) {
          return function() {
            return _this.appendText(text);
          };
        })(this));
      } else if (this.textEditor && text.length > 0) {
        if (text[text.length - 1] !== "\n") {
          text = text + "\n";
        }
        this.modifyTextWith((function(_this) {
          return function() {
            var insertRange, insertionPoint;
            insertionPoint = new Point(_this.delimiterRow);
            insertRange = _this.textEditor.getBuffer().insert(insertionPoint, text);
            return _this.delimiterRow = insertRange.end.row;
          };
        })(this));
        return this.autoscroll();
      }
    };

    ReplTextEditor.prototype.info = function(text) {
      return this.appendText(text, true);
    };

    ReplTextEditor.prototype.stderr = function(text) {
      return this.appendText(text);
    };

    ReplTextEditor.prototype.stdout = function(text) {
      return this.appendText(text);
    };

    ReplTextEditor.prototype.result = function(text) {
      return this.appendText(text);
    };

    ReplTextEditor.prototype.doc = function(text) {
      return this.appendText(text);
    };

    ReplTextEditor.prototype.displayExecutedCode = function(code) {
      return this.appendText(code);
    };

    ReplTextEditor.prototype.executeEnteredText = function() {
      var code, editor;
      if (editor = atom.workspace.getActiveTextEditor()) {
        if (editor === this.textEditor) {
          code = this.enteredText();
          this.clearEnteredText();
          this.replHistory.setLastTextAndAddNewEntry(code);
          return window.protoRepl.executeCode(code, {
            displayCode: code,
            doBlock: true
          });
        }
      }
    };

    return ReplTextEditor;

  })();

}).call(this);
