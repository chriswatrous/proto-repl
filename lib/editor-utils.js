// Generated by CoffeeScript 1.12.7
(function() {
  var CompositeDisposable, EditorUtils, Point, Range, edn_reader, ref;

  ref = require('atom'), CompositeDisposable = ref.CompositeDisposable, Range = ref.Range, Point = ref.Point;

  edn_reader = require('./proto_repl/edn_reader.js');

  module.exports = EditorUtils = {
    escapeClojureCodeInString: function(code) {
      var escaped;
      escaped = code.replace(/\\/g, "\\\\").replace(/"/g, "\\\"");
      return "\"" + escaped + "\"";
    },
    findNsDeclaration: function(editor) {
      var e, i, len, range, ref1, txt;
      ref1 = this.getTopLevelRanges(editor);
      for (i = 0, len = ref1.length; i < len; i++) {
        range = ref1[i];
        txt = editor.getTextInBufferRange(range);
        try {
          if (txt.match(/^\(ns /)) {
            return edn_reader.parse(txt)[1];
          }
        } catch (error) {
          e = error;
          return null;
        }
      }
    },
    isPosInClojureMarkdown: function(editor, pos) {
      var scopeDesc;
      scopeDesc = editor.scopeDescriptorForBufferPosition(pos);
      return scopeDesc.scopes.indexOf("markup.code.clojure.gfm") >= 0;
    },
    findMarkdownCodeBlockStartPosition: function(editor, fromPos) {
      var scanRange, startPos;
      startPos = null;
      scanRange = new Range([0, 0], fromPos.translate(new Point(0, 10)));
      editor.backwardsScanInBufferRange(/```clojure/ig, scanRange, function(result) {
        startPos = result.range.start.translate(new Point(1, 0));
        return result.stop();
      });
      return startPos;
    },
    findMarkdownCodeBlockEndPosition: function(editor, fromPos) {
      var endPos, scanRange;
      endPos = null;
      scanRange = new Range(fromPos, editor.buffer.getEndPosition());
      editor.scanInBufferRange(/```/g, scanRange, function(result) {
        endPos = result.range.start;
        return result.stop();
      });
      return endPos;
    },
    isIgnorableBrace: function(editor, pos) {
      var scopes;
      scopes = editor.scopeDescriptorForBufferPosition(pos).scopes;
      return scopes.indexOf("string.quoted.double.clojure") >= 0 || scopes.indexOf("comment.line.semicolon.clojure") >= 0 || scopes.indexOf("string.regexp.clojure") >= 0;
    },
    findBlockStartPosition: function(editor, fromPos) {
      var braceClosed, openToClose, startPos;
      braceClosed = {
        "}": 0,
        ")": 0,
        "]": 0
      };
      openToClose = {
        "{": "}",
        "[": "]",
        "(": ")"
      };
      startPos = null;
      editor.backwardsScanInBufferRange(/[\{\}\[\]\(\)]/g, new Range([0, 0], fromPos), (function(_this) {
        return function(result) {
          var c;
          if (!(_this.isIgnorableBrace(editor, result.range.start))) {
            c = "" + result.match[0];
            if (braceClosed[c] !== void 0) {
              return braceClosed[c]++;
            } else {
              braceClosed[openToClose[c]]--;
              if (braceClosed[openToClose[c]] === -1) {
                startPos = result.range.start;
                return result.stop();
              }
            }
          }
        };
      })(this));
      return startPos;
    },
    findBlockEndPosition: function(editor, fromPos) {
      var braceOpened, closeToOpen, endPos, scanRange;
      braceOpened = {
        "{": 0,
        "(": 0,
        "[": 0
      };
      closeToOpen = {
        "}": "{",
        "]": "[",
        ")": "("
      };
      endPos = null;
      scanRange = new Range(fromPos, editor.buffer.getEndPosition());
      editor.scanInBufferRange(/[\{\}\[\]\(\)]/g, scanRange, (function(_this) {
        return function(result) {
          var c;
          if (!(_this.isIgnorableBrace(editor, result.range.start))) {
            c = "" + result.match[0];
            if (braceOpened[c] !== void 0) {
              return braceOpened[c]++;
            } else {
              braceOpened[closeToOpen[c]]--;
              if (braceOpened[closeToOpen[c]] === -1) {
                endPos = result.range.start;
                return result.stop();
              }
            }
          }
        };
      })(this));
      return endPos;
    },
    directlyAfterBlockRange: function(editor) {
      var pos, previousChar, previousPos, startPos;
      pos = editor.getCursorBufferPosition();
      if (pos.column > 0) {
        previousPos = new Point(pos.row, pos.column - 1);
        previousChar = editor.getTextInBufferRange(new Range(previousPos, pos));
        if ([")", "}", "]"].indexOf(previousChar) >= 0) {
          if (startPos = this.findBlockStartPosition(editor, previousPos)) {
            return new Range(startPos, pos);
          }
        }
      }
    },
    directlyBeforeBlockRange: function(editor) {
      var afterChar, closingPos, endPos, pos, subsequentPos;
      pos = editor.getCursorBufferPosition();
      subsequentPos = pos.translate(new Point(0, 1));
      afterChar = editor.getTextInBufferRange(new Range(pos, subsequentPos));
      if (["(", "{", "["].indexOf(afterChar) >= 0) {
        if (endPos = this.findBlockEndPosition(editor, subsequentPos)) {
          closingPos = endPos.translate(new Point(0, 1));
          return new Range(pos, closingPos);
        }
      }
    },
    getCursorInClojureBlockRange: function(editor) {
      var closingPos, endPos, pos, range, startPos;
      if (range = this.directlyAfterBlockRange(editor)) {
        return range;
      } else if (range = this.directlyBeforeBlockRange(editor)) {
        return range;
      } else {
        pos = editor.getCursorBufferPosition();
        startPos = this.findBlockStartPosition(editor, pos);
        endPos = this.findBlockEndPosition(editor, pos);
        if (startPos && endPos) {
          closingPos = endPos.translate(new Point(0, 1));
          return new Range(startPos, closingPos);
        }
      }
    },
    getCursorInMarkdownBlockRange: function(editor) {
      var endPos, pos, startPos;
      pos = editor.getCursorBufferPosition();
      if (this.isPosInClojureMarkdown(editor, pos)) {
        if (startPos = this.findMarkdownCodeBlockStartPosition(editor, pos)) {
          if (endPos = this.findMarkdownCodeBlockEndPosition(editor, startPos)) {
            return new Range(startPos, endPos);
          }
        }
      }
    },
    getCursorInBlockRange: function(editor, arg) {
      var range, topLevel;
      topLevel = (arg != null ? arg : {
        topLevel: false
      }).topLevel;
      if (topLevel && (range = this.getCursorInClojureTopBlockRange(editor, {
        lookInComments: true
      }))) {
        return range;
      } else if (range = this.getCursorInClojureBlockRange(editor)) {
        return range;
      } else {
        return this.getCursorInMarkdownBlockRange(editor);
      }
    },
    getTopLevelRanges: function(editor, arg) {
      var braceOpened, inTopLevelComment, lookInComments, ranges, rex;
      lookInComments = (arg != null ? arg : {
        lookInComments: false
      }).lookInComments;
      ranges = [];
      braceOpened = 0;
      inTopLevelComment = false;
      if (lookInComments) {
        rex = /(\(comment\s|[\{\}\[\]\(\)])/g;
      } else {
        rex = /[\{\}\[\]\(\)]/g;
      }
      editor.scan(rex, (function(_this) {
        return function(result) {
          var c, matchesComment;
          if (!(_this.isIgnorableBrace(editor, result.range.start))) {
            matchesComment = result.matchText.match(/^\(comment\s/);
            if (matchesComment && braceOpened === 0) {
              inTopLevelComment = true;
            }
            c = "" + result.match[0];
            if (["(", "{", "["].indexOf(c) >= 0 || matchesComment) {
              if ((braceOpened === 1 && inTopLevelComment === true) || (braceOpened === 0 && inTopLevelComment === false)) {
                ranges.push([result.range.start]);
              }
              return braceOpened++;
            } else if ([")", "}", "]"].indexOf(c) >= 0) {
              braceOpened--;
              if ((braceOpened === 1 && inTopLevelComment === true) || (braceOpened === 0 && inTopLevelComment === false)) {
                ranges[ranges.length - 1].push(result.range.end);
              }
              if (braceOpened === 0 && inTopLevelComment === true) {
                return inTopLevelComment = false;
              }
            }
          }
        };
      })(this));
      return ranges.filter(function(range) {
        return range.length === 2;
      }).map(function(range) {
        return Range.fromObject(range);
      });
    },
    getCursorInClojureTopBlockRange: function(editor, options) {
      var pos, topLevelRanges;
      if (options == null) {
        options = {};
      }
      pos = editor.getCursorBufferPosition();
      topLevelRanges = this.getTopLevelRanges(editor, options);
      return topLevelRanges.find(function(range) {
        return range.containsPoint(pos);
      });
    },
    findEditorRangeContainingString: function(str) {
      var editor, editors, foundRange, i, len, regex;
      editors = atom.workspace.getTextEditors();
      regex = new RegExp(str.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
      for (i = 0, len = editors.length; i < len; i++) {
        editor = editors[i];
        foundRange = null;
        editor.scan(regex, (function(_this) {
          return function(matched) {
            foundRange = matched.range;
            return matched.stop();
          };
        })(this));
        if (foundRange) {
          return [editor, foundRange];
        }
      }
    }
  };

}).call(this);
