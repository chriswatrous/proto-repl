// Generated by CoffeeScript 1.12.7
(function() {
  var CompletionProvider, CompositeDisposable, EditorUtils, Emitter, ExtensionsFeature, NReplConnectionView, Point, Range, Repl, SaveRecallFeature, edn_reader, path, ref, url;

  edn_reader = require('./proto_repl/edn_reader.js');

  ref = require('atom'), CompositeDisposable = ref.CompositeDisposable, Range = ref.Range, Point = ref.Point, Emitter = ref.Emitter;

  NReplConnectionView = require('./views/nrepl-connection-view');

  Repl = require('./repl');

  url = require('url');

  path = require('path');

  EditorUtils = require('./editor-utils');

  SaveRecallFeature = require('./features/save-recall-feature');

  ExtensionsFeature = require('./features/extensions-feature');

  CompletionProvider = require('./completion-provider');

  module.exports = {
    subscriptions: null,
    repl: null,
    toolbar: null,
    ink: null,
    EditorUtils: EditorUtils,
    edn_reader: edn_reader,
    saveRecallFeature: null,
    extensionsFeature: null,
    executeSelectedText: function(options) {
      var editor, range, selectedText, varName;
      if (options == null) {
        options = {};
      }
      if (editor = atom.workspace.getActiveTextEditor()) {
        selectedText = editor.getSelectedText();
        range = editor.getSelectedBufferRange();
        if (selectedText === "") {
          if (varName = this.getClojureVarUnderCursor(editor)) {
            selectedText = varName;
            range.end.column = 2e308;
          }
        }
        options.inlineOptions = {
          editor: editor,
          range: range
        };
        options.displayCode = selectedText;
        options.doBlock = true;
        return this.executeCodeInNs(selectedText, options);
      }
    },
    parseEdn: function(ednString) {
      return edn_reader.parse(ednString);
    },
    prettyEdn: function(ednString) {
      var error;
      try {
        return edn_reader.pretty_print(ednString);
      } catch (error1) {
        error = error1;
        return ednString;
      }
    },
    ednToDisplayTree: function(ednString) {
      var error;
      try {
        return edn_reader.to_display_tree(ednString);
      } catch (error1) {
        error = error1;
        return [ednString];
      }
    },
    ednSavedValuesToDisplayTrees: function(ednString) {
      var error;
      try {
        return edn_reader.saved_values_to_display_trees(ednString);
      } catch (error1) {
        error = error1;
        console.log(error);
        return [];
      }
    },
    jsToEdn: function(jsData) {
      return edn_reader.js_to_edn(jsData);
    },
    executeRanges: function(editor, ranges) {
      var code, range;
      if (range = ranges.shift()) {
        code = editor.getTextInBufferRange(range);
        return this.executeCodeInNs(code, {
          inlineOptions: {
            editor: editor,
            range: range
          },
          displayInRepl: false,
          resultHandler: (function(_this) {
            return function(result, options) {
              _this.repl.inlineResultHandler(result, options);
              return _this.executeRanges(editor, ranges);
            };
          })(this)
        });
      }
    },
    autoEvalCurrent: function() {
      var editor;
      if (!atom.config.get('proto-repl.showInlineResults')) {
        window.protoRepl.stderr("Auto Evaling is not supported unless inline results is enabled");
        return null;
      }
      if (!this.ink) {
        window.protoRepl.stderr("Install Atom Ink package to use auto evaling.");
        return null;
      }
      if (editor = atom.workspace.getActiveTextEditor()) {
        if (editor.protoReplAutoEvalDisposable) {
          return window.protoRepl.stderr("Already auto evaling");
        } else {
          editor.protoReplAutoEvalDisposable = editor.onDidStopChanging((function(_this) {
            return function() {
              var ref1;
              if ((ref1 = _this.ink) != null) {
                ref1.Result.removeAll(editor);
              }
              return _this.executeRanges(editor, EditorUtils.getTopLevelRanges(editor));
            };
          })(this));
          return this.executeRanges(editor, EditorUtils.getTopLevelRanges(editor));
        }
      }
    },
    stopAutoEvalCurrent: function() {
      var editor;
      if (editor = atom.workspace.getActiveTextEditor()) {
        if (editor.protoReplAutoEvalDisposable) {
          editor.protoReplAutoEvalDisposable.dispose();
          return editor.protoReplAutoEvalDisposable = null;
        }
      }
    },
    getClojureVarUnderCursor: function(editor) {
      var word;
      word = EditorUtils.getClojureVarUnderCursor(editor);
      if (word === "") {
        window.protoRepl.stderr("This command requires you to position the cursor on a Clojure var.");
        return null;
      } else {
        return word;
      }
    },
    prettyPrint: function() {
      return this.executeCode("(do (require 'clojure.pprint) (clojure.pprint/pp))");
    },
    refreshNamespacesCommand: "(do (try (require 'user) (catch java.io.FileNotFoundException e (println (str \"No user namespace defined. Defaulting to clojure.tools.namespace.repl/refresh.\\n\")))) (try (require 'clojure.tools.namespace.repl) (catch java.io.FileNotFoundException e (println \"clojure.tools.namespace.repl not available. Add proto-repl in your project.clj as a dependency to allow refresh. See https://clojars.org/proto-repl\"))) (let [user-reset 'user/reset ctnr-refresh 'clojure.tools.namespace.repl/refresh result (cond (find-var user-reset) ((resolve user-reset)) (find-var ctnr-refresh) ((resolve ctnr-refresh)) :else (println (str \"You can use your own refresh function, just define reset function in user namespace\\n\" \"See this https://github.com/clojure/tools.namespace#reloading-code-motivation for why you should use it\")))] (when (isa? (type result) Exception) (println (.getMessage result))) result))",
    refreshResultHandler: function(callback, result) {
      if (result.value) {
        window.protoRepl.info("Refresh complete");
        this.extensionsFeature.startExtensionRequestProcessing();
        if (callback) {
          return callback();
        }
      } else if (result.error) {
        return window.protoRepl.stderr("Refresh Warning: " + result.error);
      }
    },
    refreshNamespaces: function(callback) {
      if (callback == null) {
        callback = null;
      }
      if (window.protoRepl.isSelfHosted()) {
        return window.protoRepl.stderr("Refreshing not supported in self hosted REPL.");
      } else {
        window.protoRepl.info("Refreshing code...\n");
        return this.executeCode(this.refreshNamespacesCommand, {
          displayInRepl: false,
          resultHandler: (function(_this) {
            return function(result) {
              return _this.refreshResultHandler(callback, result);
            };
          })(this)
        });
      }
    },
    superRefreshNamespaces: function(callback) {
      if (callback == null) {
        callback = null;
      }
      if (window.protoRepl.isSelfHosted()) {
        return window.protoRepl.stderr("Refreshing not supported in self hosted REPL.");
      } else {
        window.protoRepl.info("Clearing all and then refreshing code...\n");
        return this.executeCode("(do (when (find-ns 'clojure.tools.namespace.repl) (eval '(clojure.tools.namespace.repl/clear))) " + this.refreshNamespacesCommand + ")", {
          displayInRepl: false,
          resultHandler: (function(_this) {
            return function(result) {
              return _this.refreshResultHandler(callback, result);
            };
          })(this)
        });
      }
    },
    loadCurrentFile: function() {
      var editor, fileName;
      if (editor = atom.workspace.getActiveTextEditor()) {
        if (window.protoRepl.isSelfHosted()) {
          return window.protoRepl.stderr("Loading files is not supported yet in self hosted REPL.");
        } else {
          fileName = editor.getPath().replace(/\\/g, "\\\\");
          return this.executeCode("(do (println \"Loading File " + fileName + "\") (load-file \"" + fileName + "\"))");
        }
      }
    },
    runTestsInNamespace: function() {
      var code, editor;
      if (editor = atom.workspace.getActiveTextEditor()) {
        if (window.protoRepl.isSelfHosted()) {
          return window.protoRepl.stderr("Running tests is not supported yet in self hosted REPL.");
        } else {
          code = "(clojure.test/run-tests)";
          if (atom.config.get("proto-repl.refreshBeforeRunningTestFile")) {
            return this.refreshNamespaces((function(_this) {
              return function() {
                return _this.executeCodeInNs(code);
              };
            })(this));
          } else {
            return this.executeCodeInNs(code);
          }
        }
      }
    },
    runTestUnderCursor: function() {
      var code, editor, testName;
      if (editor = atom.workspace.getActiveTextEditor()) {
        if (window.protoRepl.isSelfHosted()) {
          return window.protoRepl.stderr("Running tests is not supported yet in self hosted REPL.");
        } else {
          if (testName = this.getClojureVarUnderCursor(editor)) {
            code = "(do (clojure.test/test-vars [#'" + testName + "]) (println \"tested " + testName + "\"))";
            if (atom.config.get("proto-repl.refreshBeforeRunningSingleTest")) {
              return this.refreshNamespaces((function(_this) {
                return function() {
                  return _this.executeCodeInNs(code);
                };
              })(this));
            } else {
              return this.executeCodeInNs(code);
            }
          }
        }
      }
    },
    runAllTests: function() {
      if (window.protoRepl.isSelfHosted()) {
        return window.protoRepl.stderr("Running tests is not supported yet in self hosted REPL.");
      } else {
        return this.refreshNamespaces((function(_this) {
          return function() {
            return _this.executeCode("(def all-tests-future (future (time (clojure.test/run-all-tests))))");
          };
        })(this));
      }
    },
    printVarDocumentation: function() {
      var code, editor, handled, inlineHandler, parser, range, varName;
      if (editor = atom.workspace.getActiveTextEditor()) {
        if (varName = this.getClojureVarUnderCursor(editor)) {
          if (window.protoRepl.isSelfHosted()) {
            code = "(with-out-str (doc " + varName + "))";
            parser = function(value) {
              return value.replace(/^-+\n/, '');
            };
          } else {
            code = "(do (require 'clojure.repl) (with-out-str (clojure.repl/doc " + varName + ")))";
            parser = (function(_this) {
              return function(value) {
                return _this.parseEdn(value).replace(/^-+\n/, '');
              };
            })(this);
          }
          if (this.ink && atom.config.get('proto-repl.showInlineResults')) {
            range = editor.getSelectedBufferRange();
            range.end.column = 2e308;
            inlineHandler = this.repl.makeInlineHandler(editor, range, (function(_this) {
              return function(value) {
                return [
                  varName, {
                    a: 1
                  }, [parser(value)]
                ];
              };
            })(this));
          }
          handled = false;
          return this.executeCodeInNs(code, {
            displayInRepl: false,
            resultHandler: (function(_this) {
              return function(value) {
                var msg;
                if (handled) {
                  return;
                }
                handled = true;
                if (typeof inlineHandler === "function") {
                  inlineHandler(value);
                }
                if (value.value) {
                  msg = parser(value.value).trim();
                  if (msg) {
                    return window.protoRepl.doc(msg);
                  } else {
                    return window.protoRepl.stderr("No doc found for " + varName);
                  }
                } else if (value.error) {
                  return window.protoRepl.stderr(value.error);
                } else {
                  msg = 'Did not get value or error.';
                  console.error(msg, value);
                  throw new Error(msg);
                }
              };
            })(this)
          });
        }
      }
    },
    printVarCode: function() {
      var code, editor, varName;
      if (editor = atom.workspace.getActiveTextEditor()) {
        if (varName = this.getClojureVarUnderCursor(editor)) {
          if (window.protoRepl.isSelfHosted()) {
            return window.protoRepl.stderr("Showing source code is not yet supported in self hosted REPL.");
          } else {
            code = "(do (require 'clojure.repl) (clojure.repl/source " + varName + "))";
            return this.executeCodeInNs(code);
          }
        }
      }
    },
    listNsVars: function() {
      var code, editor, nsName;
      if (editor = atom.workspace.getActiveTextEditor()) {
        if (nsName = this.getClojureVarUnderCursor(editor)) {
          if (window.protoRepl.isSelfHosted()) {
            return window.protoRepl.stderr("Listing namespace functions is not yet supported in self hosted REPL.");
          } else {
            code = "(do (require 'clojure.repl) (let [selected-symbol '" + nsName + " selected-ns (get (ns-aliases *ns*) selected-symbol selected-symbol)] (println \"\\nVars in\" (str selected-ns \":\")) (println \"------------------------------\") (doseq [s (clojure.repl/dir-fn selected-ns)] (println s)) (println \"------------------------------\")))";
            return this.executeCodeInNs(code);
          }
        }
      }
    },
    listNsVarsWithDocs: function() {
      var code, editor, nsName;
      if (editor = atom.workspace.getActiveTextEditor()) {
        if (nsName = this.getClojureVarUnderCursor(editor)) {
          if (window.protoRepl.isSelfHosted()) {
            return window.protoRepl.stderr("Listing namespace functions is not yet supported in self hosted REPL.");
          } else {
            code = "(do (require 'clojure.repl) (let [selected-symbol '" + nsName + " selected-ns (get (ns-aliases *ns*) selected-symbol selected-symbol)] (println (str \"\\n\" selected-ns \":\")) (println \"\" (:doc (meta (the-ns selected-ns)))) (doseq [s (clojure.repl/dir-fn selected-ns) :let [m (-> (str selected-ns \"/\" s) symbol find-var meta)]] (println \"---------------------------\") (println (:name m)) (cond (:forms m) (doseq [f (:forms m)] (print \"  \") (prn f)) (:arglists m) (prn (:arglists m))) (println \" \" (:doc m))) (println \"------------------------------\")))";
            return this.executeCodeInNs(code);
          }
        }
      }
    },
    openFileContainingVar: function() {
      var editor, selected, text;
      if (window.protoRepl.isSelfHosted()) {
        return window.protoRepl.stderr("Opening files containing vars is not yet supported in self hosted REPL.");
      } else {
        if (editor = atom.workspace.getActiveTextEditor()) {
          if (selected = this.getClojureVarUnderCursor(editor)) {
            text = "(do (require 'clojure.repl) (require 'clojure.java.shell) (require 'clojure.java.io) (import [java.io File]) (import [java.util.jar JarFile]) (let [var-sym '" + selected + " the-var (or (some->> (or (get (ns-aliases *ns*) var-sym) (find-ns var-sym)) clojure.repl/dir-fn first name (str (name var-sym) \"/\") symbol) var-sym) {:keys [file line protocol]} (meta (eval `(var ~the-var))) _ (when (and (nil? file) protocol) (throw (Exception. (format \"The var %s is part of a protocol which Proto REPL is currently unable to open.\" var-sym)))) file-path (loop [paths (remove empty? (clojure.string/split (.getPath (.toURI (java.io.File. file))) #\"/\"))] (when-not (empty? paths) (let [path (clojure.string/join \"/\" paths) res (.getResource (clojure.lang.RT/baseLoader) path)] (if-not (nil? res) (let [uri (.normalize (.toURI (.getResource (clojure.lang.RT/baseLoader) path)))] (if (.isOpaque uri) (let [url (.toURL uri) conn (.openConnection url) file (java.io.File. (.. conn getJarFileURL toURI))] (str (.getAbsolutePath file) \"!\" (second (clojure.string/split (.getPath url) #\"!\")))) (.getAbsolutePath (java.io.File. uri)))) (recur (rest paths))))))] (if-let [[_ jar-path partial-jar-path within-file-path] (re-find #\"(.+\\.m2.repository.(.+\\.jar))!/(.+)\" file-path)] (let [decompressed-path (.getAbsolutePath (File. (.getAbsolutePath (File. (System/getProperty \"user.home\") \"/.lein/tmp-atom-jars/\")) partial-jar-path)) decompressed-file-path (.getAbsolutePath (File. decompressed-path within-file-path)) decompressed-path-dir (clojure.java.io/file decompressed-path)] (when-not (.exists decompressed-path-dir) (println \"decompressing\" jar-path \"to\" decompressed-path) (.mkdirs decompressed-path-dir) (let [jar-file (JarFile. jar-path)] (run! (fn [jar-entry] (let [file (File. decompressed-path (.getName jar-entry))] (when-not (.isDirectory jar-entry) (.mkdirs (.getParentFile file)) (with-open [is (.getInputStream jar-file jar-entry)] (clojure.java.io/copy is file))))) (seq (.toArray (.stream jar-file)))))) [decompressed-file-path line]) [file-path line])))";
            return this.executeCodeInNs(text, {
              displayInRepl: false,
              resultHandler: (function(_this) {
                return function(result) {
                  var file, line, ref1;
                  if (result.value) {
                    window.protoRepl.info("Opening " + result.value);
                    ref1 = _this.parseEdn(result.value), file = ref1[0], line = ref1[1];
                    file = file.replace(/%20/g, " ");
                    return atom.workspace.open(file, {
                      initialLine: line - 1,
                      searchAllPanes: true
                    });
                  } else {
                    return window.protoRepl.stderr("Error trying to open: " + result.error);
                  }
                };
              })(this)
            });
          }
        }
      }
    },
    remoteNreplFocusNext: function() {
      if (this.connectionView != null) {
        return this.connectionView.toggleFocus();
      }
    }
  };

}).call(this);
