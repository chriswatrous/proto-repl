// Generated by CoffeeScript 1.12.7
(function() {
  var CompletionProvider, CompositeDisposable, EditorUtils, Emitter, ExtensionsFeature, NReplConnectionView, Point, Range, Repl, SaveRecallFeature, edn_reader, path, ref, url;

  edn_reader = require('./proto_repl/edn_reader.js');

  ref = require('atom'), CompositeDisposable = ref.CompositeDisposable, Range = ref.Range, Point = ref.Point, Emitter = ref.Emitter;

  NReplConnectionView = require('./views/nrepl-connection-view');

  Repl = require('./repl');

  url = require('url');

  path = require('path');

  EditorUtils = require('./editor-utils');

  SaveRecallFeature = require('./features/save-recall-feature');

  ExtensionsFeature = require('./features/extensions-feature');

  CompletionProvider = require('./completion-provider');

  module.exports = {
    subscriptions: null,
    repl: null,
    toolbar: null,
    ink: null,
    EditorUtils: EditorUtils,
    edn_reader: edn_reader,
    saveRecallFeature: null,
    extensionsFeature: null,
    listNsVarsWithDocs: function() {
      var code, editor, nsName;
      if (editor = atom.workspace.getActiveTextEditor()) {
        if (nsName = window.protoRepl.getClojureVarUnderCursor(editor)) {
          if (window.protoRepl.isSelfHosted()) {
            return window.protoRepl.stderr("Listing namespace functions is not yet supported in self hosted REPL.");
          } else {
            code = "(do (require 'clojure.repl) (let [selected-symbol '" + nsName + " selected-ns (get (ns-aliases *ns*) selected-symbol selected-symbol)] (println (str \"\\n\" selected-ns \":\")) (println \"\" (:doc (meta (the-ns selected-ns)))) (doseq [s (clojure.repl/dir-fn selected-ns) :let [m (-> (str selected-ns \"/\" s) symbol find-var meta)]] (println \"---------------------------\") (println (:name m)) (cond (:forms m) (doseq [f (:forms m)] (print \"  \") (prn f)) (:arglists m) (prn (:arglists m))) (println \" \" (:doc m))) (println \"------------------------------\")))";
            return window.protoRepl.executeCodeInNs(code);
          }
        }
      }
    },
    openFileContainingVar: function() {
      var editor, selected, text;
      if (window.protoRepl.isSelfHosted()) {
        return window.protoRepl.stderr("Opening files containing vars is not yet supported in self hosted REPL.");
      } else {
        if (editor = atom.workspace.getActiveTextEditor()) {
          if (selected = window.protoRepl.getClojureVarUnderCursor(editor)) {
            text = "(do (require 'clojure.repl) (require 'clojure.java.shell) (require 'clojure.java.io) (import [java.io File]) (import [java.util.jar JarFile]) (let [var-sym '" + selected + " the-var (or (some->> (or (get (ns-aliases *ns*) var-sym) (find-ns var-sym)) clojure.repl/dir-fn first name (str (name var-sym) \"/\") symbol) var-sym) {:keys [file line protocol]} (meta (eval `(var ~the-var))) _ (when (and (nil? file) protocol) (throw (Exception. (format \"The var %s is part of a protocol which Proto REPL is currently unable to open.\" var-sym)))) file-path (loop [paths (remove empty? (clojure.string/split (.getPath (.toURI (java.io.File. file))) #\"/\"))] (when-not (empty? paths) (let [path (clojure.string/join \"/\" paths) res (.getResource (clojure.lang.RT/baseLoader) path)] (if-not (nil? res) (let [uri (.normalize (.toURI (.getResource (clojure.lang.RT/baseLoader) path)))] (if (.isOpaque uri) (let [url (.toURL uri) conn (.openConnection url) file (java.io.File. (.. conn getJarFileURL toURI))] (str (.getAbsolutePath file) \"!\" (second (clojure.string/split (.getPath url) #\"!\")))) (.getAbsolutePath (java.io.File. uri)))) (recur (rest paths))))))] (if-let [[_ jar-path partial-jar-path within-file-path] (re-find #\"(.+\\.m2.repository.(.+\\.jar))!/(.+)\" file-path)] (let [decompressed-path (.getAbsolutePath (File. (.getAbsolutePath (File. (System/getProperty \"user.home\") \"/.lein/tmp-atom-jars/\")) partial-jar-path)) decompressed-file-path (.getAbsolutePath (File. decompressed-path within-file-path)) decompressed-path-dir (clojure.java.io/file decompressed-path)] (when-not (.exists decompressed-path-dir) (println \"decompressing\" jar-path \"to\" decompressed-path) (.mkdirs decompressed-path-dir) (let [jar-file (JarFile. jar-path)] (run! (fn [jar-entry] (let [file (File. decompressed-path (.getName jar-entry))] (when-not (.isDirectory jar-entry) (.mkdirs (.getParentFile file)) (with-open [is (.getInputStream jar-file jar-entry)] (clojure.java.io/copy is file))))) (seq (.toArray (.stream jar-file)))))) [decompressed-file-path line]) [file-path line])))";
            return window.protoRepl.executeCodeInNs(text, {
              displayInRepl: false,
              resultHandler: (function(_this) {
                return function(result) {
                  var file, line, ref1;
                  if (result.value) {
                    window.protoRepl.info("Opening " + result.value);
                    ref1 = window.protoRepl.parseEdn(result.value), file = ref1[0], line = ref1[1];
                    file = file.replace(/%20/g, " ");
                    return atom.workspace.open(file, {
                      initialLine: line - 1,
                      searchAllPanes: true
                    });
                  } else {
                    return window.protoRepl.stderr("Error trying to open: " + result.error);
                  }
                };
              })(this)
            });
          }
        }
      }
    },
    remoteNreplFocusNext: function() {
      if (this.connectionView != null) {
        return this.connectionView.toggleFocus();
      }
    }
  };

}).call(this);
