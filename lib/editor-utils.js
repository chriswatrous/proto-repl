// Generated by CoffeeScript 1.12.7
(function() {
  var CompositeDisposable, EditorUtils, Point, Range, edn_reader, ref;

  ref = require('atom'), CompositeDisposable = ref.CompositeDisposable, Range = ref.Range, Point = ref.Point;

  edn_reader = require('./proto_repl/edn_reader.js');

  module.exports = EditorUtils = {
    isPosInClojureMarkdown: function(editor, pos) {
      var scopeDesc;
      scopeDesc = editor.scopeDescriptorForBufferPosition(pos);
      return scopeDesc.scopes.indexOf("markup.code.clojure.gfm") >= 0;
    },
    findMarkdownCodeBlockStartPosition: function(editor, fromPos) {
      var scanRange, startPos;
      startPos = null;
      scanRange = new Range([0, 0], fromPos.translate(new Point(0, 10)));
      editor.backwardsScanInBufferRange(/```clojure/ig, scanRange, function(result) {
        startPos = result.range.start.translate(new Point(1, 0));
        return result.stop();
      });
      return startPos;
    },
    findMarkdownCodeBlockEndPosition: function(editor, fromPos) {
      var endPos, scanRange;
      endPos = null;
      scanRange = new Range(fromPos, editor.buffer.getEndPosition());
      editor.scanInBufferRange(/```/g, scanRange, function(result) {
        endPos = result.range.start;
        return result.stop();
      });
      return endPos;
    },
    isIgnorableBrace: function(editor, pos) {
      var scopes;
      scopes = editor.scopeDescriptorForBufferPosition(pos).scopes;
      return scopes.indexOf("string.quoted.double.clojure") >= 0 || scopes.indexOf("comment.line.semicolon.clojure") >= 0 || scopes.indexOf("string.regexp.clojure") >= 0;
    },
    findBlockStartPosition: function(editor, fromPos) {
      var braceClosed, openToClose, startPos;
      braceClosed = {
        "}": 0,
        ")": 0,
        "]": 0
      };
      openToClose = {
        "{": "}",
        "[": "]",
        "(": ")"
      };
      startPos = null;
      editor.backwardsScanInBufferRange(/[\{\}\[\]\(\)]/g, new Range([0, 0], fromPos), (function(_this) {
        return function(result) {
          var c;
          if (!(_this.isIgnorableBrace(editor, result.range.start))) {
            c = "" + result.match[0];
            if (braceClosed[c] !== void 0) {
              return braceClosed[c]++;
            } else {
              braceClosed[openToClose[c]]--;
              if (braceClosed[openToClose[c]] === -1) {
                startPos = result.range.start;
                return result.stop();
              }
            }
          }
        };
      })(this));
      return startPos;
    },
    findBlockEndPosition: function(editor, fromPos) {
      var braceOpened, closeToOpen, endPos, scanRange;
      braceOpened = {
        "{": 0,
        "(": 0,
        "[": 0
      };
      closeToOpen = {
        "}": "{",
        "]": "[",
        ")": "("
      };
      endPos = null;
      scanRange = new Range(fromPos, editor.buffer.getEndPosition());
      editor.scanInBufferRange(/[\{\}\[\]\(\)]/g, scanRange, (function(_this) {
        return function(result) {
          var c;
          if (!(_this.isIgnorableBrace(editor, result.range.start))) {
            c = "" + result.match[0];
            if (braceOpened[c] !== void 0) {
              return braceOpened[c]++;
            } else {
              braceOpened[closeToOpen[c]]--;
              if (braceOpened[closeToOpen[c]] === -1) {
                endPos = result.range.start;
                return result.stop();
              }
            }
          }
        };
      })(this));
      return endPos;
    },
    directlyAfterBlockRange: function(editor) {
      var pos, previousChar, previousPos, startPos;
      pos = editor.getCursorBufferPosition();
      if (pos.column > 0) {
        previousPos = new Point(pos.row, pos.column - 1);
        previousChar = editor.getTextInBufferRange(new Range(previousPos, pos));
        if ([")", "}", "]"].indexOf(previousChar) >= 0) {
          if (startPos = this.findBlockStartPosition(editor, previousPos)) {
            return new Range(startPos, pos);
          }
        }
      }
    },
    directlyBeforeBlockRange: function(editor) {
      var afterChar, closingPos, endPos, pos, subsequentPos;
      pos = editor.getCursorBufferPosition();
      subsequentPos = pos.translate(new Point(0, 1));
      afterChar = editor.getTextInBufferRange(new Range(pos, subsequentPos));
      if (["(", "{", "["].indexOf(afterChar) >= 0) {
        if (endPos = this.findBlockEndPosition(editor, subsequentPos)) {
          closingPos = endPos.translate(new Point(0, 1));
          return new Range(pos, closingPos);
        }
      }
    },
    getCursorInClojureBlockRange: function(editor) {
      var closingPos, endPos, pos, range, startPos;
      if (range = this.directlyAfterBlockRange(editor)) {
        return range;
      } else if (range = this.directlyBeforeBlockRange(editor)) {
        return range;
      } else {
        pos = editor.getCursorBufferPosition();
        startPos = this.findBlockStartPosition(editor, pos);
        endPos = this.findBlockEndPosition(editor, pos);
        if (startPos && endPos) {
          closingPos = endPos.translate(new Point(0, 1));
          return new Range(startPos, closingPos);
        }
      }
    },
    getCursorInMarkdownBlockRange: function(editor) {
      var endPos, pos, startPos;
      pos = editor.getCursorBufferPosition();
      if (this.isPosInClojureMarkdown(editor, pos)) {
        if (startPos = this.findMarkdownCodeBlockStartPosition(editor, pos)) {
          if (endPos = this.findMarkdownCodeBlockEndPosition(editor, startPos)) {
            return new Range(startPos, endPos);
          }
        }
      }
    }
  };

}).call(this);
